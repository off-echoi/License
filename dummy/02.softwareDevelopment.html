<html lang="ko-kr">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2. 소프트웨어 개발</title>
    <link rel="stylesheet" href="./common.css" />
</head>
<body>
    <strong>1. 데이터 입·출력 구현</strong>
    <div class="paper">
        <section>
            <header>
                <h2>034. 자료 구조</h2>
                <ul>
                    <li>자료의 표현과 관련된 연산자</li>
                    <li>자료의 조직화, 구조화</li>
                    <li>필요한 모든 연산을 처리 가능</li>
                    <li>자료 구조에 따라 프로그램 실행 시간이 달라짐</li>
                </ul>
            </header>
            <ul>
                <li>
                    <h4>자료구조의 분류</h4>
                </li>
                <li>
                    <table>
                        <colgroup>
                            <col width="110px">
                            <col width="110px">
                        </colgroup>
                        <tr>
                            <th rowspan="6">선형구조</th>
                            <td colspan="2">배열(Array)</td>
                        </tr>
                        <tr>
                            <td rowspan="2">선형리스트(Linear List)</td>
                            <td>연속 리스트(Contiguous List)</td>
                        </tr>
                        <tr>
                            <td>연결 리스트(Linked List)</td>
                        </tr>
                        <tr>
                            <td colspan="2">스택(Steak)</td>
                        </tr>
                        <tr>
                            <td colspan="2">큐(Queue)</td>
                        </tr>
                        <tr>
                            <td colspan="2">데크(Deque)</td>
                        </tr>
                        <tr>
                            <th rowspan="2">
                                비선형구조
                            </th>
                            <td colspan="2">트리(Tree)</td>
                        </tr>
                        <tr>
                            <td colspan="2">그래프(Graph)</td>
                        </tr>
                    </table>
                </li>
            </ul>
            <ol>
                <li>
                    <h3>선형 : 배열(Array)</h3>
                    <ul>
                        <li>동일한 자료형 데이터, 같은 크기로 나열 <b>순서를 가지고있음</b></li>
                        <li>정적인 자료구조 = 기억장소의 추가 어려움</li>
                        <li>데이터 삭제 => 기억장소 빈공간 = <b>메모리 낭비 발생</b></li>
                        <li>첨자[n]로 데이터 접근 / 첨자의 갯수에 따라 n차원 배열이라고 부름</li>
                        <li>반복적 데이터 처리 작업</li>
                        <li>데이터마다 동일한 이름 사용 => 처리 간편</li>
                    </ul>
                </li>
                <li>
                    <h3>선형 : 선형리스트(Linear List)</h3>
                    <ul>
                        <li>일정한 순서로 나열</li>
                        <li><b>연속 리스트 : 배열사용</b>/ <b>연결 리스트 : 포인터 사용</b></li>
                        <li>
                            <dl>
                                <dt>연속 리스트(Contiguous List)</dt>
                                <dd>연속되는 기억저장소 리스트</dd>
                                <dd>삽입, 삭제시 자료의 이동 => 기억장소 이용 효율이 좋다(밀도1) / 데이터 삽입을 위해선 연속적인 기억공간 필요</dd>
                                <dt>연결 리스트(Linked List)</dt>
                                <dd>반드시 연속적으로 자료를 배열시지키지 않음 = 임이의 기억공간에 기억</dd>
                                <dd>자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 연결</dd>
                                <dd>노드의 삽입. 삭제 용이</dd>
                                <dd>기억공간이 연속적이지 않아도 됨(포인터 사용)</dd>
                                <dd>포인터(링크)가 있으므로 기억공간의 효율이 좋지 않음</dd>
                                <dd>포인터가 가리키는 곳으로 이동해야하기 때문에 접근속도가 느림</dd>
                                <dd>중간 노드 연결이 끊어지면 다음 노드를 찾기 힘들다</dd>
                            </dl>
                        </li>
                    </ul>
                </li>
                <li>
                    <h3>선형 : 스택(Stack)</h3>
                    <ul>
                        <li><b class="red">한쪽에서만 자료의 삽입, 삭제</b></li>
                        <li>나중에 삽인된 자료가 먼저 삭제 <b>후입선출(LIFO)</b></li>
                        <li>스택의 기억공간이 꽉차면 <b>오버플로발생</b>, 삭제할 데이터가 없는데 삭제하면 <b>언더플로발생</b></li>
                        <li>TOP : 스택에서 가장 마지막 자료가 삽입된 기억 위치</li>
                        <li>Bottom : 스택의 가장 밑 바닥</li>
                    </ul>
                </li>
                <li>
                    <h3>선형 : 큐(Queue)</h3>
                    <ul>
                        <li>한쪽 삽입, 한쪽 삭제</li>
                        <li>먼저 삽입 => 먼저 삭제 <b>후입선출(FIFO)</b></li>
                        <li><b>운영체제의 작업 스케줄링에 사용</b></li>
                        <li>프런트 포인터 : 먼저 삽입된 기억공간</li>
                        <li>리어 포인터 : 마지막에 삽입된 기억공간(삽입시 사용)</li>
                    </ul>
                </li>
            </ol>
            <ol>
                <li>
                    <h3>비선형 : 트리(TREE)</h3>
                    <ul>
                        <li><img src="https://3.bp.blogspot.com/-mkXOdT8GI_4/VK-ZG9KdLgI/AAAAAAAAAWE/6v5dmUDJShg/s1600/%ED%8A%B8%EB%A6%AC%EA%B5%AC%EC%A1%B0_2.PNG"
                                alt=""></li>
                        <li>정점(노드)와 선분(브랜치)를 이용하여 사이클을 이루지 않도록 구성하는 그래프</li>
                        <li>노드 : 하나의 기억공간 / 링크 : 노드와 노드를 연결</li>
                        <li>족보, 조직도 등을 표현하기 적합</li>
                        <li>디그리(차수) : 각 노드에서 뻗어나온 가지 수 <br>A = 3, C = 1, B = 2</li>
                        <li>맆노드(단말노드) : 자식이 없는, 디그리가 0인 노드</li>
                        <li>트리의 디그리 : 노드의 디그리 중에서 가장 많은 수 <br>A나 D가 3개의 디그리를 가지므로 3 이다.</li>
                        <li>
                            <h4>트리의 순회 방법</h4>
                            <u>앞쪽이 중간에 들어옴, 오른쪽은 항상 왼쪽보다 뒤</u>
                            <dl>
                                <dt>중위순회</dt>
                                <dd>왼 -> 중 -> 오</dd>
                                <dt>전위순회</dt>
                                <dd>중 -> 왼 -> 오</dd>
                                <dt>후위순회</dt>
                                <dd>왼 -> 오 -> 중</dd>
                            </dl>
                        </li>
                    </ul>
                </li>
                <li>
                    <h3>비선형 : 그래프</h3>
                    <ul>
                        <li>간선의 갯수 <br> 무방향그래프 : n*(n-1)/2 <br>방향그래프 : n(n-1) <br>최소비용 신장트리 : n-1</li>
                    </ul>
                </li>
            </ol>
        </section>
        <section>
            <h2>데이터 저장소/ 데이터베이스 / DBMS</h2>
            <ul>
                <li>
                    <h3>데이터 저장소</h3>
                    <ul>
                        <li>
                            데이터를 물리적인 공간이나, 논리적인 구조로 조직화 하거나 물리적인 공간에 구축한 것
                        </li>
                        <li><b>논리저장소</b>와 <b>물리저장소가</b>가 있다.</li>
                        <li><b>논리 데이터 저장소 : </b> 데이터 및 데이터 간의 연관성, 제약조건 식별 => 논리적인 구조로 조직화</li>
                        <li><b>물리 데이터 저장소 : </b>논리저장소의 데이터를 물리적 특성을 고려해 하드웨어 저장장치에 저장</li>
                        <li>논리데이터 저장소를 거쳐 물리 데이터 저장소를 구축하는 과정 == 데이터베이스 구축 과정과 동일</li>
                    </ul>
                </li>
                <li>
                    <h3></h3>
                    <ul>
                        <li></li>
                    </ul>
                </li>
            </ul>
        </section>
    </div>
    <strong>4. 어플리케이션 관리</strong>
    <div class="paper">
        <section>
            <header>
                <h2>051. 테스트 기법 에따른 애플리케이션 테스트</h2>
            </header>
            <ol>
                <li>
                    <h3>화이트박스 테스트(WhiteBox-test)</h3>
                    <ul>
                        <li>모듈의 원시코드 오픈시킨 상태에서 테스트 <span class="red">논리적인</span> 모든 경로를 테스트</li>
                        <li>설계된 절차에 초점을 둔 구조적 테스트 <b>테스트 과정의 초기에 적용</b></li>
                        <li>모듈안의 작동을 직접 관찰</li>
                        <li>원시코드(모듈)의 모든 문장을 한번 이상 실행</li>
                        <li>선택, 반복 등의 분기점부분을 수행함으로 <b>논리적 경로를제어함</b></li>
                    </ul>
                    <h4>
                        화이트박스 테스트의 종류
                    </h4>
                    <table>
                        <tr>
                            <th>기초 경로 검사</th>
                            <td>
                                <ul>
                                    <li>대표적인 화이트박스 기법</li>
                                    <li>설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 기법</li>
                                    <li>테스트 결과는 실행경로의 기초를 정의하는 지침으로 사용</li>
                                </ul>
                            </td>
                        </tr>
                        <tr>
                            <th>제어 구조 검사</th>
                            <td>
                                <dl>
                                    <dt>조건 검사(Condition Testing)</dt>
                                    <dd>모듈 내의 논리적 조건을 테스트</dd>
                                    <dt>루프 검사(Loop Testing)</dt>
                                    <dd>프로그램의 반복 구조에 초점을 맞춰 실시</dd>
                                    <dt>데이터 흐름 검사(Data Flow Testing)</dt>
                                    <dd>변수의 정의와 변수 사용 위치에 초점을 맞춰 실시 </dd>
                                </dl>
                            </td>
                        </tr>
                    </table>
                    <h4>화이트박스 테스트의 검증 기준 (모드 코드 커버리지에 속함: 구조 코드가 얼마나 테스트 되었는지 측정)</h4>
                    <table>
                        <tr>
                            <th>문장 검증 기준<br>(Statement Coverage)</th>
                            <td>모든 구문이 한 번 이상 실행되도록 케이스 설계</td>
                        </tr>
                        <tr>
                            <th>분기 검증 기준<br>(Branch Coverage)</th>
                            <td>모든 조건문이 한 번 이상 수행되도록 설계</td>
                        </tr>
                        <tr>
                            <th>조건 검증 기준<br>(Condition Coverage)</th>
                            <td>조건이 true/false인 경우가 한 번 이상 수행되도록</td>
                        </tr>
                        <tr>
                            <th>분기/조건 기준<br>(Branch/Condition Coverage)</th>
                            <td>모든 조건문과 각 조건문의 true/false 를 한번 이상 수행되도록</td>
                        </tr>
                    </table>
                </li>
                <li>
                    <h3>블랙박스 테스트(Black Box Test)</h3>
                    <ul>
                        <li><b>= 기능 테스트</b></li>
                        <li>사용자의 요구사항 명세르 보며 진행, 구현된 기능을 테스트 함</li>
                        <li>소프트웨어 인터페이스에서 실행</li>
                        <li>테스트 과정의 후반부 / 기능누락, 인텉페이스 오류 등</li>
                    </ul>
                    <h4>블랙박스 테스트의 종류</h4>
                    <table>
                        <tr>
                            <th>동치 분할 검사<br>(Equvalance Partitioning Testing)</th>
                            <td><ul>
                                <li>입력자료에 초점을 맞춰 테스트</li>
                                <li>타당한 입력자료/타당하지 않은 입력자료 를 입력 => 자료에 맞는 결과가 출력되는지 확인</li>
                            </ul></td>
                        </tr>
                        <tr>
                            <th>경계값 분석<br>(Boundary Value Analysis)</th>
                            <td>
                                <ul>
                                    <li>동치분할 보완</li>
                                    <li>입력조건의 경계값을 테스트 케이스로 선정</li>
                                </ul>
                            </td>
                        </tr>
                        <tr>
                            <th>원인-효과 그래프 검사<br>(Cause-Effect Graphing Testing)</th>
                            <td>입력데이터간의 관계와 출력에 영양을 미치는 상황을 체계적으로 분석</td>
                        </tr>
                        <tr>
                            <tr>오류 예측 검사 = 데이터 확인 검사<br>(Error Guessing)</tr>
                            <td>과거의 경험과 감각으로 예측 <br> 다른 블랙박스와 이루어져 보충적 검사기법</td>
                        </tr>
                        <tr>
                            <th>비교 검사<br>(Comparsion Testing)</th>
                            <td>다른 버전의 프로그램에 동일한 테스트 자료로 테스트</td>
                        </tr>
                    </table>
                </li>
            </ol>
        </section>
        <section>
            <header>
                <h2>개발 단계에 따른 애플리케이션 테스트</h2>
                <ul>
                    <li><img src="https://lh3.googleusercontent.com/proxy/chECVphw4y8VF24GciqbJsCdQ20vNnVPmcZqex8LNaka-oyJyJzPWHeYzOrKb9dbPwzPPDEU43YmIDz1ZGw-EjdhZZA22ZsJL_5z7Lf9-gRo_PfbksVEeCPZ7xOAuf5q-sTzU3eBYfO_WHhKWO7sL_3tQ12wKiP8" alt=""></li>
                    <li>개발단계에서부터 테스트를 수행 => 요구분석의 오류, 설계오류 등 발견</li>
                    <li><span class="red">V-모델</span> : 애플리케이션 테스트와 소프트웨어 개발단계를 연결하여 표현한 것</li>
                </ul>
                <ol>
                    <li>
                        <h3>단위 테스트(Unit-Test)</h3>
                        <ul>
                            <li>설계의 최소 단위인 모듈이나 컴포넌트 중심 테스트</li>
                            <li>인터페이스, 외부적 I/O,자료구조, 독립적 기초경로, 오류처리경로, 경계조건검사</li>
                            <li>기능성 테스트 최우선</li>
                            <li>
                                <table>
                                    <tr>
                                        <th>구조기반 테스트</th>
                                        <td>주로 사용 됨 <br>프로그램 구조 및 복잡도를 검증하는 화이트박스테스트 시행</td>
                                        <td>제어흐름, 조건설정</td>
                                    </tr>
                                    <tr>
                                        <th>명세기반 테스트</th>
                                        <td>목적 및 실행코드 기반의 블랙박스 테스트 시행</td>
                                        <td>동등 분할, 경계 값 분석</td>
                                    </tr>
                                </table>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <h3>통합 테스트(Intergration Test)</h3>
                        <ul>
                            <li>단위테스트 완료 후 모듈 결합하는 과정에서의 테스트</li>
                            <li>모듈 간 또는 통합된 컴포넌트간의 상호작용 오류 검사</li>
                            <li>
                                <dl>
                                    <dt>비점진적 통합방식</dt>
                                    <dd>모듈이 미리 결합되어있는 프로그램 전체를 테스트</dd>
                                    <dd>빅뱅통합테스트 방식</dd>
                                    <dd>빅뱅통합테스트 방식</dd>
                                </dl>
                                <dl>
                                    <dt>점진적 통합방식</dt>
                                    <dd>하향식, 상향식, 혼합식 방식</dd>
                                    <dd>오류수정 용이, 인터페이스와 관련된 오류를 완전히테스트할 가능성이 높음</dd>
                                </dl>
                            </li>
                            <li>
                                <h4>하향식 통합 테스트(Top Down Intergration Test)</h4>
                                <ul>
                                    <li>상위에서 하위로 내려오며 통합하며 테스트</li>
                                    <li>
                                        <img src="https://t1.daumcdn.net/cfile/tistory/23062A3E591DC9C330" alt="">
                                        <dl>
                                            <dt>깊이우선 통합</dt>
                                            <dd>주요제어모듈기준으로 종속된 모듈 통합</dd>
                                            <dt>넓이 우선 통합</dt>
                                            <dd>구조의 수평을 중심으로 해당하는 모듈 통합</dd>
                                        </dl>

                                    </li>
                                    <li>테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 있음</li>
                                    <li>상위모듈에서는 테스트케이스 사용에 어려움</li>
                                    <li><b>절차</b> 
                                        <ol>
                                            <li>주요 제어 모듈은 작성된 프로그램 사용, <br>주요 제어 모듈의 종속모듈은 스텁(Stub)으로 대체</li>
                                            <li>통합방법을 따라 하위모듈인 스텁들이 한번에 하나씩 실제 모듈로 교체</li>
                                            <li>모듈이 통합될 때마다 테스트 시행</li>
                                            <li>새로운 오류가 발생하지 않음을 보증하기 위해 회귀테스트 진행</li>
                                        </ol>
                                    </li>
                                </ul>
                                <h4>상향식 통합 테스트(Bottom Up Intergration Test)</h4>
                                <ol>
                                    <li>하위 모듈을 클러스터로 통합</li>
                                    <li>상위모듈에서 데이터의 입출력을 확인하기 위해 더미모듈인 드라이버를 작성</li>
                                    <li>통합된 클러스터 단위로 테스트</li>
                                    <li>테스트 완료 후 클러스터는 구조의 상위로 이동하여 결합, 드라이버는 실제 모듈로 대체</li>
                                </ul>
                                <h4>혼합식 통합 테스트</h4>
                                <ul>
                                    <li>하위에서는 상향식 통합, 상위에서는 하향식통합</li>
                                    <li>샌드위치 통합테스트</li>
                                </ul>
                                <h4>회귀 테스팅(Regression Testing)</h4>
                                <ul>
                                    <li>이미 테스트 된 프로그램의 테스팅 반복</li>
                                    <li>새로운 오류가 있는지 확인</li>
                                    <li>수정한 모듈이나 컴포넌트가 다른부분에 영향을 미치는디, 오류가 생기는지 테스트</li>
                                    <li>시간과 비용이 많이 듦으로 기존 테스트케이스중 변경된 부분만 테스트(그래도 모든케이스를 하는것이 좋다)</li>
                                    <li>
                                        케이스 선정방법
                                        <ul>
                                            <li></li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <h3>시스템 테스트(System Test)</h3>
                        <ul>
                            <li>개발된 소프트웨어가 시스템에서 수행되는가</li>
                            <li>장애리스크를 최소화하기 위해서 실제 사용환경과 유사하게 만든다</li>
                            <li>
                                <table>
                                    <tr>
                                        <th>기능적 요구사항</th>
                                        <td>요구사항 명세서, 비즈니스 절차 등 <b>블랙박스</b> 테스트 실행</td>
                                    </tr>
                                    <tr>
                                        <th>비기능적요구사항</th>
                                        <td>성능테스트, 내부시스템 구조 등 <b>화이트박스</b> 테스트 시행</td>
                                    </tr>
                                </table>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <h3>인수 테스트(Acception Test)</h3>
                        <ul>
                            <li>사용자의 요구사항을 충족하는지에 중점을 두고 테스트</li>
                            <li>사용자가 직접 테스트</li>
                            <li>문제없을 시 사용자는 소프트웨어 인수 => 프로젝트 종료</li>
                            <li>
                                <table>
                                    <tr>
                                        <th>사용자 인수 테스트</th>
                                        <td>사용자가 시스템 사용의 적절성 여부 확인</td>
                                    </tr>
                                    <tr>
                                        <th>운영상의 인수 테스트</th>
                                        <td>시스템관리자가 시스템 인수시 수행, <br>백업,재난복구,정기점검 등 확인</td>
                                    </tr>
                                    <tr>
                                        <th>계약 인수 테스트</th>
                                        <td>계약상의 인수/검수 조건을 준수하는지 여부 확인</td>
                                    </tr>
                                    <tr>
                                        <th>규정 인수 테스트</th>
                                        <td>정부지침, 법구 등 규정에 맞게 개발되었는지 확인</td>
                                    </tr>
                                    <tr>
                                        <th>알파 테스트</th>
                                        <td>개발자 앞에서 행하는 테스트 <br>통제된 환경에서 실시<br> 오류등의 문제를 개발자와 사용자가 확인하며 기록</td>
                                    </tr>
                                    <tr>
                                        <th>베타 테스트</th>
                                        <td>선정된 최종 사용자가 여러명 앞에서 <br>개발자에 의해 제어되지 않은 상태에서 테스트 실행 <br>오류와 사용상의 문제를 개발자에게 주기적으로 보고</td>
                                    </tr>
                                </table>
                            </li>
                        </ul>
                    </li>
                </ol>
            </header>

        </section>
    </div>
    <script src="common.js"></script>

</body>

</html>